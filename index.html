import React, { useEffect, useRef } from 'react';

const RipplePuddle = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const ripples = [];
    let startTime = Date.now();

    const colors = [
      { r: 44, g: 83, b: 100 },
      { r: 65, g: 105, b: 125 },
      { r: 30, g: 80, b: 110 },
      { r: 40, g: 95, b: 115 },
      { r: 50, g: 75, b: 95 }
    ];

    const getWaterColor = (time) => {
      const period = 10;
      const progress = (time % period) / period;
      const colorIndex = Math.floor(progress * colors.length);
      const nextColorIndex = (colorIndex + 1) % colors.length;
      const colorProgress = (progress * colors.length) % 1;

      const currentColor = colors[colorIndex];
      const nextColor = colors[nextColorIndex];

      return {
        r: Math.floor(currentColor.r + (nextColor.r - currentColor.r) * colorProgress),
        g: Math.floor(currentColor.g + (nextColor.g - currentColor.g) * colorProgress),
        b: Math.floor(currentColor.b + (nextColor.b - currentColor.b) * colorProgress)
      };
    };

    class Tadpole {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = Math.random() * 0.5 + 0.5;
        this.targetAngle = this.angle;
        this.turnSpeed = 0;
        this.nextDirectionChange = Date.now() + Math.random() * 3000 + 1000;
      }

      update(width, height, time, ripples) {
        // Normal swimming behavior
        if (Date.now() > this.nextDirectionChange) {
          this.targetAngle = this.angle + (Math.random() - 0.5) * Math.PI;
          this.turnSpeed = (Math.random() - 0.5) * 0.1;
          this.nextDirectionChange = Date.now() + Math.random() * 3000 + 1000;
        }

        // React to ripples
        ripples.forEach(ripple => {
          const age = (Date.now() - ripple.startTime) / 1000;
          if (age < 1.5) { // Only react to recent ripples
            const dx = this.x - ripple.x;
            const dy = this.y - ripple.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < ripple.radius + 50 && distance > 0) {
              // Calculate scatter angle and force
              const scatterAngle = Math.atan2(dy, dx);
              const force = Math.max(0, 1 - distance / (ripple.radius + 50));
              const scatterSpeed = force * 5 * Math.exp(-age * 2);
              
              // Apply scatter force
              this.x += Math.cos(scatterAngle) * scatterSpeed;
              this.y += Math.sin(scatterAngle) * scatterSpeed;
              
              // Adjust tadpole angle to face away from ripple
              this.targetAngle = scatterAngle;
              this.angle = scatterAngle;
            }
          }
        });

        const angleDiff = (this.targetAngle - this.angle + Math.PI * 3) % (Math.PI * 2) - Math.PI;
        this.angle += angleDiff * 0.02;

        // Normal swimming movement
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;

        // Screen wrapping
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
      }

      draw(ctx, time) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.fillStyle = 'rgba(150, 150, 150, 0.9)';
        ctx.beginPath();
        ctx.ellipse(-4, 0, 8, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(-4, 0);
        const wiggle = Math.sin(time * 10) * 1;
        ctx.quadraticCurveTo(-12, wiggle, -20, wiggle * 2);
        ctx.strokeStyle = 'rgba(150, 150, 150, 0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
      }
    }

    const tadpoles = Array.from({ length: 33 }, () => 
      new Tadpole(Math.random() * canvas.width, Math.random() * canvas.height)
    );

    const windLayers = Array.from({ length: 2 }, () => ({
      xFreq: Math.random() * 0.003 + 0.002,
      yFreq: Math.random() * 0.003 + 0.002,
      speed: Math.random() * 0.2 + 0.15,
      amplitude: Math.random() * 1.5 + 1.0
    }));

    const generateLilyPads = (width, height) => {
      const pads = [];
      const targetCoverage = width * height * 0.15;
      let currentCoverage = 0;
      
      while (currentCoverage < targetCoverage) {
        const padSize = Math.random() * 40 + 30;
        const pad = {
          x: Math.random() * width,
          y: Math.random() * height,
          size: padSize,
          points: [],
          baseColor: {
            r: Math.random() * 30 + 30,
            g: Math.random() * 50 + 130,
            b: Math.random() * 30 + 30
          }
        };

        for (let px = -padSize; px <= padSize; px += 3) {
          for (let py = -padSize; py <= padSize; py += 3) {
            const distFromCenter = Math.sqrt(px * px + py * py);
            if (distFromCenter <= padSize) {
              if (Math.random() > distFromCenter / padSize * 0.3) {
                pad.points.push({ x: px, y: py });
              }
            }
          }
        }

        pads.push(pad);
        currentCoverage += Math.PI * padSize * padSize;
      }
      return pads;
    };

    let lilyPads = [];

    const getWindDisplacement = (x, y, time) => {
      let displacement = 0;
      windLayers.forEach(layer => {
        displacement += Math.sin(
          x * layer.xFreq + 
          y * layer.yFreq + 
          time * layer.speed
        ) * layer.amplitude;
      });
      return displacement;
    };

    const getRippleDisplacement = (x, y, time) => {
      let displacement = 0;
      ripples.forEach(ripple => {
        const age = (time - ripple.startTime) / 1000;
        if (age < 3) {
          ripple.radius = age * 200;
          const dx = x - ripple.x;
          const dy = y - ripple.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < ripple.radius) {
            const wavePhase = (distance - ripple.radius) * 0.05;
            const amplitude = ripple.amplitude * Math.exp(-age * 2);
            displacement += Math.sin(wavePhase) * amplitude * (1 - distance / ripple.maxRadius);
          }
        }
      });
      return displacement;
    };
    
    const handleResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      lilyPads = generateLilyPads(canvas.width, canvas.height);
    };

    const handleClick = (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      
      ripples.push({
        x,
        y,
        radius: 0,
        maxRadius: Math.max(canvas.width, canvas.height),
        startTime: Date.now(),
        amplitude: 15
      });
    };

    const draw = () => {
      const currentTime = Date.now();
      const elapsedTime = (currentTime - startTime) / 1000;
      
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Remove old ripples
      for (let i = ripples.length - 1; i >= 0; i--) {
        const age = (currentTime - ripples[i].startTime) / 1000;
        if (age > 3) ripples.splice(i, 1);
      }
      
      const waterColor = getWaterColor(elapsedTime);
      
      // Draw water with changing colors
      for (let y = 0; y < canvas.height; y += 3) {
        for (let x = 0; x < canvas.width; x += 3) {
          const windEffect = getWindDisplacement(x, y, elapsedTime);
          const rippleEffect = getRippleDisplacement(x, y, currentTime);
          const totalDisplacement = windEffect + rippleEffect;
          
          const intensity = 0.8 + totalDisplacement * 0.03;
          const alpha = Math.max(0.6, Math.min(0.9, intensity));
          
          ctx.fillStyle = `rgba(
            ${waterColor.r + totalDisplacement * 5},
            ${waterColor.g + totalDisplacement * 5},
            ${waterColor.b + totalDisplacement * 5},
            ${alpha})`;
          
          ctx.fillRect(x, y + totalDisplacement, 2, 2);
        }
      }

      // Draw lily pads
      lilyPads.forEach(pad => {
        pad.points.forEach(point => {
          const worldX = pad.x + point.x;
          const worldY = pad.y + point.y;
          
          const windEffect = getWindDisplacement(worldX, worldY, elapsedTime);
          const rippleEffect = getRippleDisplacement(worldX, worldY, currentTime);
          const totalDisplacement = windEffect + rippleEffect * 1.2;
          
          const distFromCenter = Math.sqrt(point.x * point.x + point.y * point.y);
          const colorVariation = Math.sin(distFromCenter * 0.1) * 20;
          
          ctx.fillStyle = `rgba(
            ${pad.baseColor.r + colorVariation},
            ${pad.baseColor.g + colorVariation},
            ${pad.baseColor.b + colorVariation},
            0.9)`;
          
          ctx.fillRect(
            worldX,
            worldY + totalDisplacement,
            3,
            3
          );
        });
      });

      // Draw tadpoles
      ctx.globalCompositeOperation = 'lighter';
      tadpoles.forEach(tadpole => {
        tadpole.update(canvas.width, canvas.height, elapsedTime, ripples);
        tadpole.draw(ctx, elapsedTime);
      });
      ctx.globalCompositeOperation = 'source-over';
      
      requestAnimationFrame(draw);
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    canvas.addEventListener('click', handleClick);
    draw();

    return () => {
      canvas.removeEventListener('click', handleClick);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return (
    <div className="fixed inset-0 w-full h-full">
      <canvas 
        ref={canvasRef}
        className="w-full h-full cursor-pointer bg-gray-900"
      />
    </div>
  );
};

export default RipplePuddle;
